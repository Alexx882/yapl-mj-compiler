options {
    LOOKAHEAD = 1;
    CHOICE_AMBIGUITY_CHECK = 2;
    OTHER_AMBIGUITY_CHECK = 1;
    STATIC = true;
    DEBUG_PARSER = false;
    DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
    ERROR_REPORTING = true;
    JAVA_UNICODE_ESCAPE = false;
    UNICODE_INPUT = false;
    IGNORE_CASE = false;
    USER_TOKEN_MANAGER = false;
    USER_CHAR_STREAM = false;
    BUILD_PARSER = true;
    BUILD_TOKEN_MANAGER = true;
    SANITY_CHECK = true;
    FORCE_LA_CHECK = false;
}

PARSER_BEGIN(Yapl)

package yapl.compiler;

import yapl.impl.SymbolKind;
import yapl.impl.SymbolTable;
import yapl.impl.YaplSymbol;
import yapl.interfaces.CompilerError;
import yapl.lib.CompilerMessage;
import yapl.lib.YaplException;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Stack;

/**
 * Processes a yapl file.
 *
 * Usage: java Yapl [--scan-only] [path]
 *
 * Where path is the path to a yapl source file.
 * If no source file is provided, input will be read from STDIN.
 */
public class Yapl {
    private static String progName = ""; // has to be known even on error

    private static SymbolTable symbolTable = new SymbolTable();

    public static void main(String[] args) throws FileNotFoundException {
        // parse per default
        boolean parse = true;
        String path = null;

        for (String arg : args) {
            if ("--scan-only".equalsIgnoreCase(arg)) {
                parse = false;
            } else {
                path = arg;
            }
        }

        // if no path is provided, read from STDIN
        InputStream input = path != null ? new FileInputStream(path) : System.in;

        Yapl parser = new Yapl(input);

        try {
            if (parse){
                Yapl.Program();
                CompilerMessage.printOK(progName);
            }
            else
                Yapl.PrintTokens();

        } catch (TokenMgrError | ParseException | YaplException e) {
            CompilerMessage.printError(e, progName);
        }
    }
}

PARSER_END(Yapl)

SKIP : // ignore whitespace
{
    " " | "\t" | "\n" | "\r"
}

SPECIAL_TOKEN : // comment syntax from JavaCC docs
{
  "/*" : WithinComment // switch to WithinComment state
}

<WithinComment> SPECIAL_TOKEN :
{
  "*/" : DEFAULT // switch back to normal
}

<WithinComment> MORE : // append to previous token
{
  // since the end comment "*/" is defined above, there is no need to explicitly check for it
  <~[]> // "not nothing" -> any symbol
}

TOKEN : { // Keywords. Need to be defined before <ident>
    < TRUE: "True" >
  | < FALSE: "False" >
  | < NEW: "new" >
  | < AND: "And" >
  | < OR: "Or" >
  | < IF: "If" >
  | < THEN: "Then" >
  | < ELSE: "Else" >
  | < ENDIF: "EndIf" >
  | < WHILE: "While" >
  | < DO: "Do" >
  | < ENDWHILE: "EndWhile" >
  | < RETURN: "Return" >
  | < WRITE: "Write" >
  | < BEGIN: "Begin" >
  | < END: "End" >
  | < INT: "int" >
  | < BOOL: "bool" >
  | < VOID: "void" >
  | < CONST: "Const" >
  | < RECORD: "Record" >
  | < ENDRECORD: "EndRecord" >
  | < DECLARE: "Declare" >
  | < PROCEDURE: "Procedure" >
  | < PROGRAM: "Program" >
}

TOKEN : { // operators
    < GT: ">" >
  | < GE: ">=" >
  | < LT: "<" >
  | < LE: "<=" >
  | < EQ: "==" >
  | < NE: "!=" >
  | < ADD: "+" >
  | < SUB: "-" >
  | < MUL: "*" >
  | < DIV: "/" >
  | < MOD: "%" >
  | < CONST_ASSIGN: "=" >
  | < ASSIGN: ":=" >
  | < ARR_LEN: "#" >
  | < L_BRACKET: "(" >
  | < R_BRACKET: ")" >
  | < L_SQ_BRACKET: "[" >
  | < R_SQ_BRACKET: "]" >
  | < COMMA: "," >
  | < SEMICOLON: ";" >
  | < DOT: "." >
}

TOKEN :
{
    < ident: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","_","0"-"9"] )* >
|
    < number: ( ["0"-"9"] )+ >
|
    < string: "\"" ([" ","a"-"z","A"-"Z","_","0"-"9",
                   "+","-","*","/",".",",",";",":","!","?","=","#","%","<",">","$",
                   "(",")","[","]","{","}","\\","@","&","^","|"])* "\"">
}

void Program() throws YaplException :
{Token name, endName;}
{
    <PROGRAM> name=<ident> {
    progName=name.image;

    symbolTable.openScope(true);
    symbolTable.setParentSymbol(
            new YaplSymbol(progName, SymbolKind.Program)
    );
} ( Decl() | Procedure() )* <BEGIN> StatementList() <END> endName=<ident> <DOT> {

    if(!name.image.equals(endName.image)) {
        throw new YaplException(
                CompilerError.EndIdentMismatch,
                endName.beginLine,
                endName.beginColumn
        );
    }


    symbolTable.closeScope();

    } <EOF>
}

void PrintTokens() :
{ Token t; }
{
    {
        do {
            t = getNextToken();

            // collect special tokens that appeared between t and the last token
            // access through t.specialToken (if more than one, then access recursively -> need to reverse order)
            Stack<Token> stack = new Stack<>();
            Token s = t.specialToken;
            while (s != null) {
                stack.push(s);
                s = s.specialToken;
            }

            if (!stack.empty()) {
                System.out.println("[begin special]");
                while (!stack.empty())
                    System.out.println(stack.pop().toString());
                System.out.println("[end special]");
            }

            System.out.println(t.toString());
        } while (t.kind != EOF);
    }
    <EOF >
}

void RelOp() :
{}
{
    <LT> | <LE> | <GT> | <GE>
}

void EqualOp() :
{}
{
    <EQ> | <NE>
}

void AddOp() :
{}
{
    <ADD> | <SUB>
}

void MulOp() :
{}
{
    <MUL> | <DIV> | <MOD>
}

void Literal() :
{}
{
    <TRUE> | <FALSE> | <number>
}

void Selector() :
{}
{
    ( <L_SQ_BRACKET> Expr() <R_SQ_BRACKET> | <DOT> <ident> ) [ Selector() ]
}

void ArrayLen() :
{}
{
    <ARR_LEN> <ident> [ Selector() ]
}

void PrimaryExpr() :
{}
{
    Literal() | <L_BRACKET> Expr() <R_BRACKET> | LOOKAHEAD(2) ProcedureCall() | <ident> [ Selector() ] | ArrayLen()
}

void UnaryExpr() :
{}
{
    [ AddOp() ] PrimaryExpr()
}

void MulExpr() :
{}
{
    UnaryExpr() ( MulOp() UnaryExpr() )*
}

void AddExpr() :
{}
{
    MulExpr() ( AddOp() MulExpr() )*
}

void RelExpr() :
{}
{
    AddExpr() [ RelOp() AddExpr() ]
}

void EqualExpr() :
{}
{
    RelExpr() [ EqualOp() RelExpr() ]
}

void CondAndExpr() :
{}
{
    EqualExpr() ( <AND> EqualExpr() )*
}

void CreationExpr() :
{}
{
    <NEW> NonArrayType() ( <L_SQ_BRACKET> Expr() <R_SQ_BRACKET> )*
}

void Expr() :
{}
{
    CondAndExpr() ( <OR> CondAndExpr() )* | CreationExpr()
}

void ArgumentList() :
{}
{
    Expr() ( <COMMA> Expr() )*
}

void ProcedureCall() :
{}
{
    <ident> <L_BRACKET> [ ArgumentList() ] <R_BRACKET>
}

void Assignment() :
{}
{
    <ident> [ Selector() ] <ASSIGN> Expr()
}

void IfStatement() :
{}
{
    <IF> Expr() <THEN> StatementList() [ <ELSE> StatementList() ] <ENDIF>
}

void WhileStatement() :
{}
{
    <WHILE> Expr() <DO> StatementList() <ENDWHILE>
}

void ReturnStatement() :
{}
{
    <RETURN> [ Expr() ]
}

void WriteStatement() :
{}
{
    <WRITE> <string>
}

void Statement() :
{}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() | ProcedureCall() | Block()
}

void StatementList() :
{}
{
    ( Statement() <SEMICOLON> )*
}

void Block() :
{}
{
    [ Decl() ] <BEGIN> StatementList() <END>
}

void NonArrayType() :
{}
{
    <INT> | <BOOL> | <ident>
}

void Type() :
{}
{
    NonArrayType() ( <L_SQ_BRACKET> <R_SQ_BRACKET> )*
}

void ReturnType() :
{}
{
    <VOID> | Type()
}

void ConstDecl() :
{}
{
    <CONST> <ident> <CONST_ASSIGN> Literal() <SEMICOLON>
}

void VarDecl() :
{}
{
    Type() <ident> ( <COMMA> <ident> )* <SEMICOLON>
}

void TypeDecl() :
{}
{
    <RECORD> <ident> VarDecl() ( VarDecl() )* <ENDRECORD> <SEMICOLON>
}

void Decl() :
{}
{
    <DECLARE> ( ConstDecl() | VarDecl() | TypeDecl() )*
}

void FormalParam() :
{}
{
    Type() <ident>
}

void FormalParamList() :
{}
{
    FormalParam() ( <COMMA> FormalParam() )*
}

void Procedure() throws YaplException :
{Token name, endName;}
{
    <PROCEDURE> ReturnType() name=<ident> {

    String procName = name.image;

    symbolTable.openScope();
    symbolTable.setParentSymbol(
            new YaplSymbol(procName, SymbolKind.Procedure)
    );

    } <L_BRACKET> [ FormalParamList() ] <R_BRACKET> Block() endName=<ident> <SEMICOLON> {

    if(!procName.equals(endName.image)) {
            throw new YaplException(
                    CompilerError.EndIdentMismatch,
                    endName.beginLine,
                    endName.beginColumn
            );
        }


        symbolTable.closeScope();
    }
}
