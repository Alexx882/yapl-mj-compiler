options {
    LOOKAHEAD = 1;
    CHOICE_AMBIGUITY_CHECK = 2;
    OTHER_AMBIGUITY_CHECK = 1;
    STATIC = true;
    DEBUG_PARSER = false;
    DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
    ERROR_REPORTING = true;
    JAVA_UNICODE_ESCAPE = false;
    UNICODE_INPUT = false;
    IGNORE_CASE = false;
    USER_TOKEN_MANAGER = false;
    USER_CHAR_STREAM = false;
    BUILD_PARSER = true;
    BUILD_TOKEN_MANAGER = true;
    SANITY_CHECK = true;
    FORCE_LA_CHECK = false;
}

PARSER_BEGIN(Yapl)

package yapl.compiler;

import yapl.impl.*;
import yapl.interfaces.*;
import yapl.lib.*;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Stack;

/**
 * Processes a yapl file.
 *
 * Usage: java Yapl [--scan-only] [path]
 *
 * Where path is the path to a yapl source file.
 * If no source file is provided, input will be read from STDIN.
 */
public class Yapl {
    private static String progName = ""; // has to be known even on error

    private static SymbolTable symbolTable = new SymbolTable();

    public static void main(String[] args) throws FileNotFoundException {
        // parse per default
        boolean parse = true;
        String path = null;

        for (String arg : args) {
            if ("--scan-only".equalsIgnoreCase(arg)) {
                parse = false;
            } else {
                path = arg;
            }
        }

        // if no path is provided, read from STDIN
        InputStream input = path != null ? new FileInputStream(path) : System.in;

        Yapl parser = new Yapl(input);

        try {
            if (parse){
                Yapl.Program();
                CompilerMessage.printOK(progName);
            }
            else
                Yapl.PrintTokens();

        } catch (TokenMgrError | ParseException | YaplException e) {
            CompilerMessage.printError(e, progName);
        }
    }
}

PARSER_END(Yapl)

SKIP : // ignore whitespace
{
    " " | "\t" | "\n" | "\r"
}

SPECIAL_TOKEN : // comment syntax from JavaCC docs
{
  "/*" : WithinComment // switch to WithinComment state
}

<WithinComment> SPECIAL_TOKEN :
{
  "*/" : DEFAULT // switch back to normal
}

<WithinComment> MORE : // append to previous token
{
  // since the end comment "*/" is defined above, there is no need to explicitly check for it
  <~[]> // "not nothing" -> any symbol
}

TOKEN : { // Keywords. Need to be defined before <ident>
    < TRUE: "True" >
  | < FALSE: "False" >
  | < NEW: "new" >
  | < AND: "And" >
  | < OR: "Or" >
  | < IF: "If" >
  | < THEN: "Then" >
  | < ELSE: "Else" >
  | < ENDIF: "EndIf" >
  | < WHILE: "While" >
  | < DO: "Do" >
  | < ENDWHILE: "EndWhile" >
  | < RETURN: "Return" >
  | < WRITE: "Write" >
  | < BEGIN: "Begin" >
  | < END: "End" >
  | < INT: "int" >
  | < BOOL: "bool" >
  | < VOID: "void" >
  | < CONST: "Const" >
  | < RECORD: "Record" >
  | < ENDRECORD: "EndRecord" >
  | < DECLARE: "Declare" >
  | < PROCEDURE: "Procedure" >
  | < PROGRAM: "Program" >
}

TOKEN : { // operators
    < GT: ">" >
  | < GE: ">=" >
  | < LT: "<" >
  | < LE: "<=" >
  | < EQ: "==" >
  | < NE: "!=" >
  | < ADD: "+" >
  | < SUB: "-" >
  | < MUL: "*" >
  | < DIV: "/" >
  | < MOD: "%" >
  | < CONST_ASSIGN: "=" >
  | < ASSIGN: ":=" >
  | < ARR_LEN: "#" >
  | < L_BRACKET: "(" >
  | < R_BRACKET: ")" >
  | < L_SQ_BRACKET: "[" >
  | < R_SQ_BRACKET: "]" >
  | < COMMA: "," >
  | < SEMICOLON: ";" >
  | < DOT: "." >
}

TOKEN :
{
    < ident: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","_","0"-"9"] )* >
|
    < number: ( ["0"-"9"] )+ >
|
    < string: "\"" ([" ","a"-"z","A"-"Z","_","0"-"9",
                   "+","-","*","/",".",",",";",":","!","?","=","#","%","<",">","$",
                   "(",")","[","]","{","}","\\","@","&","^","|"])* "\"">
}

void Program() throws YaplException :
{Token name, endName;}
{
    <PROGRAM> name=<ident> {
    progName=name.image;

    symbolTable.openScope();

    YaplSymbol symbol = new YaplSymbol(progName, SymbolKind.Program);
    symbolTable.setParentSymbol(symbol);

} ( Decl() | Procedure() )* <BEGIN> StatementList() <END> endName=<ident> <DOT> {
    symbolTable.closeScope(endName.image, true, endName.beginLine, endName.beginColumn);
    } <EOF>
}

void PrintTokens() :
{ Token t; }
{
    {
        do {
            t = getNextToken();

            // collect special tokens that appeared between t and the last token
            // access through t.specialToken (if more than one, then access recursively -> need to reverse order)
            Stack<Token> stack = new Stack<>();
            Token s = t.specialToken;
            while (s != null) {
                stack.push(s);
                s = s.specialToken;
            }

            if (!stack.empty()) {
                System.out.println("[begin special]");
                while (!stack.empty())
                    System.out.println(stack.pop().toString());
                System.out.println("[end special]");
            }

            System.out.println(t.toString());
        } while (t.kind != EOF);
    }
    <EOF >
}

void RelOp() throws YaplException :
{}
{
    <LT> | <LE> | <GT> | <GE>
}

void EqualOp() throws YaplException :
{}
{
    <EQ> | <NE>
}

void AddOp() throws YaplException :
{}
{
    <ADD> | <SUB>
}

void MulOp() throws YaplException :
{}
{
    <MUL> | <DIV> | <MOD>
}

Type Literal() throws YaplException :
{}
{
    <TRUE> {return Type.BOOL;} | <FALSE> {return Type.BOOL;} | <number> {return Type.INT;}
}

// used to access properties of records.
// f.e.: someRecord.someProperty
void Selector() throws YaplException :
{}
{
    ( <L_SQ_BRACKET> Expr() <R_SQ_BRACKET> | <DOT> <ident> ) [ Selector() ]
}

// retrieves the length of an array.
// throws an exception if the identifier is not found
// throws an exception if the "#" operator is applied to a non-array
// f.e.: #someArray
void ArrayLen() throws YaplException :
{Token t;}
{
    <ARR_LEN> t=<ident> {
    String symbolName = t.image;
    symbolTable.checkCorrectDeclarationAsArray(symbolName, t.beginLine, t.beginColumn);
    Symbol s = symbolTable.lookup(symbolName);
    if (!(s.getType() instanceof ArrayType))
        throw new YaplException(
                CompilerError.ArrayLenNotArray,
                t.beginLine, t.beginColumn,
                new YaplExceptionArgs(symbolName)
        );
}
    [ Selector() ]
}

void PrimaryExpr() throws YaplException :
{Token t;}
{
    Literal() | <L_BRACKET> Expr() <R_BRACKET> | LOOKAHEAD(2) ProcedureCall() | t=<ident> {
        String symbolName = t.image;
        symbolTable.checkCorrectDeclarationAsPrimaryExpression(symbolName, t.beginLine, t.beginColumn);
    } [ Selector() ] | ArrayLen()
}

void UnaryExpr() throws YaplException :
{}
{
    [ AddOp() ] PrimaryExpr()
}

void MulExpr() throws YaplException :
{}
{
    UnaryExpr() ( MulOp() UnaryExpr() )*
}

void AddExpr() throws YaplException :
{}
{
    MulExpr() ( AddOp() MulExpr() )*
}

void RelExpr() throws YaplException :
{}
{
    AddExpr() [ RelOp() AddExpr() ]
}

void EqualExpr() throws YaplException :
{}
{
    RelExpr() [ EqualOp() RelExpr() ]
}

void CondAndExpr() throws YaplException :
{}
{
    EqualExpr() ( <AND> EqualExpr() )*
}

void CreationExpr() throws YaplException :
{}
{
    <NEW> NonArrayType() ( <L_SQ_BRACKET> Expr() <R_SQ_BRACKET> )*
}

void Expr() throws YaplException :
{}
{
    CondAndExpr() ( <OR> CondAndExpr() )* | CreationExpr()
}

void ArgumentList() throws YaplException :
{}
{
    Expr() ( <COMMA> Expr() )*
}

// calls a procedure
// f.e.: someProcedure()
// throws an exception if the identifier is not found
void ProcedureCall() throws YaplException :
{Token t;}
{
    t=<ident> {
        String symbolName = t.image;
        symbolTable.checkCorrectDeclarationAsProcedure(symbolName, t.beginLine, t.beginColumn);
    } <L_BRACKET> [ ArgumentList() ] <R_BRACKET>
}

// assigns a value to an identifier
// f.e.: a := 7;
// throws an exception if the identifier is not found
// throws an exception if the identifier cannot be written to e.g. it is a procedure
void Assignment() throws YaplException :
{Token t;}
{
    t=<ident> {
        String symbolName = t.image;
        symbolTable.checkCorrectDeclarationAsLValue(symbolName, t.beginLine, t.beginColumn);
      } [ Selector() ] <ASSIGN> Expr()
}

void IfStatement() throws YaplException :
{}
{
    <IF> Expr() <THEN> StatementList() [ <ELSE> StatementList() ] <ENDIF>
}

void WhileStatement() throws YaplException :
{}
{
    <WHILE> Expr() <DO> StatementList() <ENDWHILE>
}

void ReturnStatement() throws YaplException :
{}
{
    <RETURN> [ Expr() ]
}

void WriteStatement() throws YaplException :
{}
{
    <WRITE> <string>
}

void Statement() throws YaplException :
{}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() | ProcedureCall() | Block()
}

void StatementList() throws YaplException :
{}
{
    ( Statement() <SEMICOLON> )*
}

void Block() throws YaplException :
{}
{
    { symbolTable.openScope(); }
    [ Decl() ] <BEGIN> StatementList() <END>
    { symbolTable.closeScope(); }
}

Type NonArrayType() throws YaplException :
{Token t;}
{
    <INT> { return Type.INT; } | <BOOL> { return Type.BOOL; } | t=<ident>
    {
        symbolTable.checkCorrectDeclarationAsTypeName(t.image, t.beginLine, t.beginColumn);
        return symbolTable.lookup(t.image).getType();
    }
}

Type Type() throws YaplException :
{int dim = 0; Type elemType;}
{
    elemType=NonArrayType() ( <L_SQ_BRACKET> <R_SQ_BRACKET> {dim++;} )*
    {
        if (dim == 0) {
            return elemType;
        } else {
            return new ArrayType(dim, elemType);
        }
    }
}

Type ReturnType() throws YaplException :
{Type type;}
{
    <VOID> { return Type.VOID; } | type=Type() { return type; }
}

// declares a constant in the current scope
// f.e.: Const len = 10;
// throws an exception if the identifier already exists
void ConstDecl() throws YaplException :
{Token t; Type type;}
{
    <CONST> t=<ident>
    {
        Symbol s = new YaplSymbol(t.image, SymbolKind.Constant);
        symbolTable.addSymbol(s, t.beginLine, t.beginColumn);
    }
    <CONST_ASSIGN> type=Literal()
    { s.setType(type); }
    <SEMICOLON>
}

// declares a constant in the current scope
// f.e.: int i, j;
// throws an exception if the identifier already exists
void VarDecl() throws YaplException :
{Token t, t2; Type type;}
{
    type=Type() t=<ident>
    {
         symbolTable.addSymbol(
                 new YaplSymbol(t.image, SymbolKind.Variable, type),
                 t.beginLine,
                 t.beginColumn
         );
     }
     ( <COMMA> t2=<ident>
         {
             symbolTable.addSymbol(
                     new YaplSymbol(t2.image, SymbolKind.Variable, type),
                     t2.beginLine,
                     t2.beginColumn
             );
         }
    )* <SEMICOLON>
}

// declares a field in a record type
// f.e.: int width, height;
// throws an exception if the identifier already exists
void FieldDecl(RecordType recordType) throws YaplException :
{Token t, t2; Type type;}
{
    type=Type() t=<ident>
    {
        symbolTable.addSymbol(
                new YaplSymbol(t.image, SymbolKind.Variable, type),
                t.beginLine,
                t.beginColumn
        );
        recordType.addField(t.image, type);
    }
    ( <COMMA> t2=<ident>
    {
        symbolTable.addSymbol(
                new YaplSymbol(t2.image, SymbolKind.Variable, type),
                t2.beginLine,
                t2.beginColumn
        );
        recordType.addField(t2.image, type);
    }
    )* <SEMICOLON>
}

// declares a Record in the current scope
// as in : RECORD
// throws an exception if the identifier already exists
void TypeDecl() throws YaplException :
{Token t;}
{
    <RECORD> t=<ident>
    {
        RecordType recordType = new RecordType();
        symbolTable.openScope(
                 new YaplSymbol(
                         t.image, SymbolKind.Typename, recordType
                 ),
                 t.beginLine,
                 t.beginColumn
        );
    }
    FieldDecl(recordType) ( FieldDecl(recordType) )* <ENDRECORD> <SEMICOLON>
    { symbolTable.closeScope(); }
}

void Decl() throws YaplException :
{}
{
    <DECLARE> ( ConstDecl() | VarDecl() | TypeDecl() )*
}

void FormalParam() throws YaplException :
{Token t; Type type;}
{
    type=Type() t=<ident> {
        symbolTable.addSymbol(
                 new YaplSymbol(
                         t.image, SymbolKind.Parameter, type
                 ),
                 t.beginLine,
                 t.beginColumn
        );
    }
}

void FormalParamList() throws YaplException :
{}
{
    FormalParam() ( <COMMA> FormalParam() )*
}

void Procedure() throws YaplException :
{Token name, endName; Type type;}
{
    <PROCEDURE> type=ReturnType() name=<ident>
    {
        symbolTable.openScope(
                new YaplSymbol(name.image, SymbolKind.Procedure, type),
                name.beginLine,
                name.beginColumn
        );
    }
    <L_BRACKET> [ FormalParamList() ] <R_BRACKET> Block() endName=<ident> <SEMICOLON>
    { symbolTable.closeScope(endName.image, false, endName.beginLine, endName.beginColumn); }
}
